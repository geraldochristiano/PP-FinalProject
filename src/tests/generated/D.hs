import Sprockell
import Data.Char

prog::[Instruction]
prog = [Compute Equal reg0 regSprID regA,
	Branch regA (Rel 6),
	ReadInstr (IndAddr regSprID),
	Receive regA,
	Compute Equal regA reg0 regB,
	Branch regB (Rel (-3)),
	Jump (Ind regA),
	Load (ImmValue (0)) regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (2)),
	Load (ImmValue (0)) regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (3)),
	Load (ImmValue (0)) regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (5)),
	Compute Equal reg0 regSprID regD,
	Branch regD (Rel 2),
	Jump (Rel 5),
	Load (ImmValue (2)) regD,
	Compute Add regPC regD regD,
	WriteInstr regD (DirAddr (1)),
	Load (ImmValue (0)) regE,
	Compute Add regE regF regF,
	Load (ImmValue (1)) regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (2)),
	Load (ImmValue (1)) regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (3)),
	TestAndSet (DirAddr (6)),
	Receive regD,
	Branch regD (Rel 2),
	Jump (Rel (-3)),
	Load (ImmValue (0)) regE,
	Compute Add regE regF regF,
	Load (ImmValue (0)) regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (4)),
	--whilst flag0andturn==0
	Load (ImmValue (0)) regE,
	Compute Add regE regF regF,
	 -- inserting continue
	Load (ImmValue (6)) regC,
	Compute Add regPC regC regC,
	Store regC (IndAddr regF),
	 -- inserting break
	Load (ImmValue (21)) regC,
	Compute Add regPC regC regC,
	Compute Incr regF regF regE,
	Store regC (IndAddr regE),
	-- whilst condition
	ReadInstr (DirAddr (2)),
	Receive regA,
	Push regA,
	ReadInstr (DirAddr (4)),
	Receive regA,
	Push regA,
	Load (ImmValue (0)) regA,
	Push regA,
	Pop regB,
	Pop regA,
	Compute Equal regA regB regA,
	Push regA,
	Pop regB,
	Pop regA,
	Compute And regA regB regA,
	Push regA,
	Pop regA,
	Branch regA (Rel 2),
	Jump (Rel (4)),
	 -- body
	Nop,
	Load (IndAddr regF) regE,
	Jump (Ind regE),
	-- body end
	Load (ImmValue (0)) regE,
	Compute Sub regF regE regF,
	 --whilst end
	ReadInstr (DirAddr (5)),
	Receive regA,
	Push regA,
	Load (ImmValue (5)) regA,
	Push regA,
	Pop regB,
	Pop regA,
	Compute Add regA regB regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (5)),
	Load (ImmValue (0)) regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (3)),
	Load (ImmValue (0)) regE,
	Compute Sub regF regE regF,
	Nop,
	Nop,
	Nop,
	Nop,
	WriteInstr reg0 (DirAddr (6)),
	TestAndSet (DirAddr (7)),
	Receive regD,
	Branch regD (Rel 2),
	Jump (Rel (-3)),
	Load (ImmValue (0)) regE,
	Compute Add regE regF regF,
	Load (ImmValue (1)) regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (4)),
	--whilst flag1andturn==1
	Load (ImmValue (0)) regE,
	Compute Add regE regF regF,
	 -- inserting continue
	Load (ImmValue (6)) regC,
	Compute Add regPC regC regC,
	Store regC (IndAddr regF),
	 -- inserting break
	Load (ImmValue (21)) regC,
	Compute Add regPC regC regC,
	Compute Incr regF regF regE,
	Store regC (IndAddr regE),
	-- whilst condition
	ReadInstr (DirAddr (3)),
	Receive regA,
	Push regA,
	ReadInstr (DirAddr (4)),
	Receive regA,
	Push regA,
	Load (ImmValue (1)) regA,
	Push regA,
	Pop regB,
	Pop regA,
	Compute Equal regA regB regA,
	Push regA,
	Pop regB,
	Pop regA,
	Compute And regA regB regA,
	Push regA,
	Pop regA,
	Branch regA (Rel 2),
	Jump (Rel (4)),
	 -- body
	Nop,
	Load (IndAddr regF) regE,
	Jump (Ind regE),
	-- body end
	Load (ImmValue (0)) regE,
	Compute Sub regF regE regF,
	 --whilst end
	ReadInstr (DirAddr (5)),
	Receive regA,
	Push regA,
	Load (ImmValue (7)) regA,
	Push regA,
	Pop regB,
	Pop regA,
	Compute Add regA regB regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (5)),
	Load (ImmValue (0)) regA,
	Push regA,
	Pop regA,
	WriteInstr regA (DirAddr (2)),
	Load (ImmValue (0)) regE,
	Compute Sub regF regE regF,
	Nop,
	Nop,
	Nop,
	Nop,
	WriteInstr reg0 (DirAddr (7)),
	Load (ImmValue (0)) regE,
	Compute Sub regF regE regF,
	Load (ImmValue (1)) regD,
	Compute NEq regSprID regD regD,
	Branch regD (Rel 4),
	Load (ImmValue 2) regD,
	WriteInstr regD (DirAddr (1)),
	Jump (Abs 2),
	Load (ImmValue 2) regC,
	ReadInstr (DirAddr (1)),
	Receive regD,
	Compute NEq regC regD regD,
	Branch regD (Rel (-3)),
	ReadInstr (DirAddr (5)),
	Receive regA,
	WriteInstr regA numberIO,
	Load (ImmValue (ord '\n')) regA,
	WriteInstr regA charIO,
	Load (ImmValue (2)) regA,
	Compute Add regPC regA regA,
	WriteInstr regA (DirAddr (1)),
	EndProg]

main = run [prog,prog]
main_1 = runWithDebugger (debuggerSimplePrintAndWait myShow) [prog,prog]
